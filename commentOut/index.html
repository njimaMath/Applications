<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LaTeX Comment Cleaner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      color-scheme: light dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 2rem 1.5rem 3rem;
      font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      line-height: 1.55;
      background: #f3f5f7;
      color: #1f2733;
    }

    .container {
      max-width: 1040px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    h1 {
      margin: 0;
      font-size: 1.9rem;
      font-weight: 700;
    }

    .description {
      margin: 0;
      font-size: 0.95rem;
      color: #4f5d73;
    }

    .panes {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    .pane {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .pane span {
      font-weight: 600;
      font-size: 0.95rem;
      color: #334155;
    }

    textarea {
      min-height: 320px;
      padding: 0.85rem;
      border: 1px solid #cbd5e1;
      border-radius: 0.75rem;
      background: #fff;
      color: inherit;
      font-size: 0.95rem;
      font-family: "Fira Code", "Source Code Pro", Menlo, Consolas, monospace;
      line-height: 1.45;
      resize: vertical;
      box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.08);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      tab-size: 2;
      white-space: pre;
      overflow-wrap: normal;
    }

    textarea:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.25);
    }

    textarea[readonly] {
      background: #f8fafc;
      color: #1f2937;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    button {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 0.6rem 1.1rem;
      background: #2563eb;
      color: #fff;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      box-shadow: 0 10px 18px -12px rgba(37, 99, 235, 0.95);
      transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    button:hover {
      background: #1d4ed8;
      box-shadow: 0 12px 22px -12px rgba(37, 99, 235, 1);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 6px 12px -10px rgba(37, 99, 235, 1);
    }

    .secondary {
      background: #0f172a;
      box-shadow: 0 10px 18px -12px rgba(15, 23, 42, 0.75);
    }

    .secondary:hover {
      background: #111c34;
      box-shadow: 0 12px 22px -12px rgba(15, 23, 42, 0.85);
    }

    .note {
      margin: 0;
      font-size: 0.85rem;
      color: #475569;
      background: #e2e8f0;
      border-radius: 0.75rem;
      padding: 0.75rem 1rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    @media (max-width: 960px) {
      body {
        padding: 1.5rem 1rem 2.5rem;
      }

      .panes {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="container">
    <header>
      <h1>LaTeX Comment Cleaner</h1>
      <p class="description">
        Paste your LaTeX on the left and use the buttons to strip different kinds of comments while keeping every blank line and space intact.
      </p>
    </header>

    <section class="panes">
      <label class="pane" for="source">
        <span>Source</span>
        <textarea id="source" spellcheck="false" placeholder="Paste your LaTeX snippet here..."></textarea>
      </label>
      <label class="pane" for="result">
        <span>Result</span>
        <textarea id="result" spellcheck="false" readonly placeholder="Processed output will appear here."></textarea>
      </label>
    </section>

    <section class="controls">
      <button type="button" data-action="percent">Remove % comments</button>
      <button type="button" data-action="iffalse">Remove \iffalse ... \fi blocks</button>
      <button type="button" data-action="both">Remove both</button>
      <button type="button" id="copyResult" class="secondary">Copy result</button>
    </section>

    <p class="note">
      Comment-only lines inside display math (\[...\] or $$...$$) are removed entirely so that no stray blanks remain and compilation stays happy.
    </p>
  </main>

  <script>
    (function () {
      const source = document.getElementById('source');
      const result = document.getElementById('result');
      const copyButton = document.getElementById('copyResult');
      const actionButtons = document.querySelectorAll('[data-action]');

      function isEscaped(text, index) {
        let backslashCount = 0;
        for (let i = index - 1; i >= 0 && text[i] === '\\'; i -= 1) {
          backslashCount += 1;
        }
        return backslashCount % 2 === 1;
      }

      const COMMENT_STRIP_ENVIRONMENTS = new Set(['align', 'align*', 'equation', 'equation*']);

      function removePercentComments(text) {
        const output = [];
        const mathContextStack = [];
        const len = text.length;
        let i = 0;

        function removeTrailingLineWhitespace() {
          while (output.length > 0) {
            const last = output[output.length - 1];
            if (last === ' ' || last === '\t') {
              output.pop();
              continue;
            }
            if (last === '\r' || last === '\n') {
              break;
            }
            break;
          }
        }

        while (i < len) {
          const char = text[i];

          if (char === '\r') {
            output.push('\r');
            i += 1;
            if (i < len && text[i] === '\n') {
              output.push('\n');
              i += 1;
            }
            continue;
          }

          if (char === '\n') {
            output.push('\n');
            i += 1;
            continue;
          }

          if (!isEscaped(text, i)) {
            if (char === '\\') {
              const next = text[i + 1];
              if (next === '[') {
                mathContextStack.push('\\[');
                output.push('\\', '[');
                i += 2;
                continue;
              }
              if (next === ']') {
                if (mathContextStack[mathContextStack.length - 1] === '\\[') {
                  mathContextStack.pop();
                }
                output.push('\\', ']');
                i += 2;
                continue;
              }
              if (text.startsWith('\\begin{', i)) {
                const braceStart = i + '\\begin{'.length;
                const braceEnd = text.indexOf('}', braceStart);
                if (braceEnd !== -1) {
                  const envName = text.slice(braceStart, braceEnd);
                  if (COMMENT_STRIP_ENVIRONMENTS.has(envName)) {
                    mathContextStack.push(`env:${envName}`);
                  }
                }
              } else if (text.startsWith('\\end{', i)) {
                const braceStart = i + '\\end{'.length;
                const braceEnd = text.indexOf('}', braceStart);
                if (braceEnd !== -1) {
                  const envName = text.slice(braceStart, braceEnd);
                  if (COMMENT_STRIP_ENVIRONMENTS.has(envName)) {
                    const expected = `env:${envName}`;
                    for (let idx = mathContextStack.length - 1; idx >= 0; idx -= 1) {
                      if (mathContextStack[idx] === expected) {
                        mathContextStack.splice(idx, 1);
                        break;
                      }
                    }
                  }
                }
              }
            } else if (char === '$' && text[i + 1] === '$') {
              const top = mathContextStack[mathContextStack.length - 1];
              if (top === '$$') {
                mathContextStack.pop();
              } else {
                mathContextStack.push('$$');
              }
              output.push('$', '$');
              i += 2;
              continue;
            }
          }

          if (char === '%' && !isEscaped(text, i)) {
            const prevNewline = Math.max(text.lastIndexOf('\n', i - 1), text.lastIndexOf('\r', i - 1));
            const lineStart = prevNewline === -1 ? 0 : prevNewline + 1;
            const before = text.slice(lineStart, i);
            const inMathBlock = mathContextStack.length > 0;
            const hasContent = /\S/.test(before);

            let j = i + 1;
            while (j < len && text[j] !== '\r' && text[j] !== '\n') {
              j += 1;
            }

            const newlineStart = j;
            let newlineLength = 0;
            if (j < len) {
              if (text[j] === '\r' && j + 1 < len && text[j + 1] === '\n') {
                newlineLength = 2;
              } else {
                newlineLength = 1;
              }
            }

            if (inMathBlock && !hasContent) {
              removeTrailingLineWhitespace();
              if (newlineLength > 0) {
                i = newlineStart + newlineLength;
              } else {
                i = newlineStart;
              }
              continue;
            }

            i = newlineStart;
            continue;
          }

          output.push(char);
          i += 1;
        }

        return output.join('');
      }

      function removeIffalseBlocks(text) {
        const startToken = '\\iffalse';
        const endToken = '\\fi';
        let cursor = 0;
        const len = text.length;
        let output = '';

        while (cursor < len) {
          const startIndex = text.indexOf(startToken, cursor);
          if (startIndex === -1) {
            output += text.slice(cursor);
            break;
          }

          output += text.slice(cursor, startIndex);
          let scan = startIndex + startToken.length;
          let depth = 1;

          while (scan < len && depth > 0) {
            if (text.startsWith(startToken, scan)) {
              depth += 1;
              scan += startToken.length;
              continue;
            }

            if (text.startsWith(endToken, scan)) {
              depth -= 1;
              scan += endToken.length;
              continue;
            }

            scan += 1;
          }

          if (depth === 0) {
            const block = text.slice(startIndex, scan);
            const newlines = block.match(/\r\n|\n|\r/g);
            if (newlines) {
              for (const nl of newlines) {
                output += nl;
              }
            }
            cursor = scan;
          } else {
            output += text.slice(startIndex);
            break;
          }
        }

        return output;
      }

      function runAction(action) {
        const value = source.value;
        let processed = value;

        if (action === 'percent') {
          processed = removePercentComments(value);
        } else if (action === 'iffalse') {
          processed = removeIffalseBlocks(value);
        } else if (action === 'both') {
          processed = removePercentComments(removeIffalseBlocks(value));
        }

        result.value = processed;
      }

      actionButtons.forEach((button) => {
        button.addEventListener('click', () => {
          runAction(button.dataset.action);
        });
      });

      copyButton.addEventListener('click', async () => {
        const textToCopy = result.value;
        if (!textToCopy) {
          return;
        }

        const reset = () => {
          copyButton.textContent = 'Copy result';
        };

        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(textToCopy);
          } else {
            result.focus();
            result.select();
            document.execCommand('copy');
            window.getSelection().removeAllRanges();
          }
          copyButton.textContent = 'Copied!';
          setTimeout(reset, 1600);
        } catch (error) {
          copyButton.textContent = 'Copy failed';
          setTimeout(reset, 2000);
        }
      });

      source.addEventListener('input', () => {
        result.value = source.value;
      });

      result.value = '';
    })();
  </script>
</body>
</html>
